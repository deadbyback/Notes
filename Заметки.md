Заметки:
======
В LandPlot следует сохранить фикс имени в архиве:
```
public function getIdentifiableName()
{
    if(isset($this->field)){
    return trim($this->field->number) . '/' . trim($this->number);}
}
```

Или лучше так:

```
public function getIdentifiableName()
if ($this->field == null) {
    return trim($this->number);
}
return trim($this->field->number) . '/' . trim($this->number);
```
В офишл добавлять не стоит, держать лишь при себе.

--------------------------------------------------------------------------------

В FieldWork стоит задуматься о выделении куска повторяющегося условия запроса в
отдельную функцию. Проблема лишь в том, что я пока не знаю, где эта фукнция
должна находиться и как к ней обращаться.

Примерная структура функции:

```
  /**
  * Filters tracks of field work and transits related to them.
  * @return $this self reference.
  */
  public function whereFieldWorkAndTransfer(\app\models\db\document\FieldWorkQuery $transferDocs)
  {
    /* @var \app\models\db\document\FieldWorkQuery $this*/
    $this->andWhere([
      'OR',
          [
            'AND',
              ['=', 'landPlotId', $this->landPlot->id],
              ['=', 'typeId', VehicleTrack::TYPE_FIELD_WORK],
          ],
          [
              'AND',
              ['IN', 'documentItemId', $transferDocs],
              ['=', 'typeId', VehicleTrack::TYPE_TRANSFER]
          ],
      ]);
    return $this;
  }
  ```

Как вариант, вложенный запрос $transferDocs можно помесить также в эту функцию.

Вопрос: **где эта фукнция должна находиться и как к ней обращаться?**

UPD: Нашёл решение проблемы. Метод выделен в VehicleTrackQuery как
whereFieldWorkAndTransferOnLandPlot и теперь выглядит так:
```
/**
     * Filters tracks of field work and transits related to them.
     * @param $landPlotId int
     * @return $this self reference.
     */
    public function whereFieldWorkAndTransferOnLandPlot(int $landPlotId)
    {
        $transferDocs =  \app\models\db\document\DocumentItem::find()
            ->select('DocumentItem.id')
            ->joinWith('document.fieldWork')
            ->where(['{{FieldWork}}.[[landPlotId]]' => $landPlotId]);

        /* @var \app\models\db\document\FieldWorkQuery $this*/
        $this->andWhere([
            'OR',
            [
                'AND',
                ['=', 'landPlotId', $landPlotId],
                ['=', 'typeId', VehicleTrack::TYPE_FIELD_WORK],
            ],
            [
                'AND',
                ['IN', 'documentItemId', $transferDocs],
                ['=', 'typeId', VehicleTrack::TYPE_TRANSFER]
            ],
        ]);
        return $this;
    }
```

--------------------------------------------------------------------------------

`->offset((($this->page ?: 1) - 1) * $this->pageSize)`

Интересная строка. Что она значит?

OFFSET указывает пропустить указанное число строк, прежде чем начать выдавать
строки. Тернарный оператор говорит следующее:
  * Если $this->page есть, то берём его
  * Иначе берём 1

Далее мы убираем 1 (равно 0) и умножаем на размер страницы. Получается что
OFFSET 0 равноценно отсутствию указания OFFSET. Но!
Если есть $this->page, то наш запрос смещается на количество элементов в
странице * на (номер страницы - 1).

--------------------------------------------------------------------------------

## TODO:
Попробовать сделать свой фреймворк. В качестве первоначальной задачи сделать REST API.

--------------------------------------------------------------------------------

> Не путать библиотеки и фреймворк.
* Библиотека: отдельный инструмент, не накладывает ограничения.
* Фреймворк: пакет инструментов, накладывает ограничения.

--------------------------------------------------------------------------------

> По возможности, стараться использовать константные выражения (именованные константы)
вместо численных значений, во избежания открытия информации.

--------------------------------------------------------------------------------

## TODO:
Что, если сделать отдельный класс обработки тех или иных ошибок?
Выделить определённые категории ошибок, сделать шаблон обработки, вывода текста сообщения etc.
И вместо вызовов локальных ошибок, подтягивать отдельный объект, с конкретной функцией.

Вопрос:
1. Не скажется ли это на производительности?
2. Не нарушит ли безопасность приложения?
3. Возможна ли вообще такая реализация?

---

При написании тех или иных методов следует обратить внимание:
1. Выделить основную цель данного метода, что он должен обработать и вернуть.
2. Подобрать ему подходящее имя (это касается и переменных).
3. Попробовать написать псевдокод.
4. Продумать обработку ошибок.
5. Исследовать функциональность, предоставляемую стандартными библиотеками и их возможное применение.
6. Продумать алгоритмы и типы данных.
7. Продумать при данных и их обработку.
8. Проверить псевдокод на соответствие вышеизложенным идеям.
9. Описать несколько идей псевдокодом и сравнить.
10. При необходимости повторить, начиная с шага 6.
11. Кодинг!


После того как код был сформирован и написан, необходимо исследовать его на предмет
соответствия поставленной задаче, а также проверить на необходимость дальнейшей
декомпозиции кода. И, конечно, приступить к тестированию этого метода.

После того как все тесты были пройдены, необходимо "навести красоту" в коде:
  * убрать лишние комментарии;
  * убрать неиспользуемые параметры и добавить объявление используемым, если такого нет;
  * при необходимости добавить документирование метода;
  * проверить форматирование кода и представить его в *читабельном для других* виде.

Нужно помнить, что *создание* **высококачественного** *ПО — итеративный процесс*,
так что не стоит бояться возвращения на предыдущий этап снова и снова.

---

Имена переменных должны соответствовать их назначению, смыслу или применению! При чтении
кода другим человеком, он должен понимать о чём идёт речь в данном фрагменте, что обозначает та
или иная переменная, каково её назначение и где она применяется. В ином случае возникает
банальное увеличение сложности кода.

Хорошее мнемоническое имя чаще всего описывает проблему, а не ее решение. Хорошее имя
в большей степени выражает **что**, а не **как**. Если же имя описывает некоторый аспект
вычислений, а не проблемы, имеет место обратное.

Следует позаботиться и о длине названия переменных (и не только). Слишком короткие имена
страдают нехваткой смысла.  Слишком длинные имена надоедает печатать, к тому же
они могут сделать неясной визуальную структуру программы.
> Бывают моменты, когда недостаточная длина названия определяет второстепенность
данной переменной и имеет ограниченную область действия (к примеру, счётчик *i*).

В качестве имени переменной, содержащей значение суммы, средней величины, максимума etc можно
(и даже рекомендуемо) применять конструкцию:
> имя + спецификатор (типа Max, Min, Total, Count etc).

В именах переменных также можно встретить и употребление антонимов. Их употребление
должно происходить последовательно. К примеру:
* begin/end;
* first/last;
* locked/unlocked;
* min/max;
* next/previous;
* old/new;
* opened/closed etc.

Бывает порой использование временных переменных. В этом случае нужно подчеркнуть
её временный (буферный) характер. Однако в этом случае должна использоваться реальная
переменная с точным описательным именем.

При именовании булевых переменных необходимо присваивать им имена, подразумевающие значение true или false,
подчёркивая утвердительность применения. Также полезно применять весьма типичные для этого имена:
* done;
* error;
* found;
* success (OK) etc.

Константы должны быть выделены как константы. Имя константы должно характеризовать абстрактную сущность,
представляемую константой, а не конкретное значение. Визуальное выделением CAPS-ом подчеркнёт лишь
её константное значение. К примеру, хорошим именем константы будет
`const MAX_AREA = 500`.

> Достаточно важной деталью является сохранение стиля формализации кода в течении всего
документа/кода, а также её приведение к определённым стандартам. Это гораздо облегчит
усваиваемость результатов труда другими людьми.

---

Важно выделить переменную-индекс в условиях циклов как отдельную, смысловую переменную.
Это позволит избежания путаницы счётчиков при вложенных циклах.

Лучше сделать тело цикла достаточно короткое, чтобы его можно было увидеть сразу целиком. Так
будет меньше проблем с чтением и путаницы как таковой не будет. При этом максимальную вложенность
лучше всего обечспечить на планке в три уровня.

Если же цикл невозможно сделать коротким или же содержит вложенные циклы, стоит задуматься о выделении
определённых кусков кода в отдельные методы. Если цикл достаточно хорошо спроектирован,
то с этим не будет особых проблем.

> **_Длина цикла увеличивает сложность!_**

Поэтому стоит преобразовывать длинные циклы в максимально короткие и предельно ясные циклы.

---

> **_Частично программирование направлено на решение задачи, а частично — на решение
этой задачи на определенном языке. Выбранный язык существенно влияет на получаемый результат._**

---

> **_Необходимо программировать с помощью языка, а не на языке._**

---

**Стоит упрощать сложную обработку ошибок с помощью сторожевых операторов (досрочных return или exit).**
Если программа вынуждена проверять большое количество ошибочных ситуаций перед выполнением номинальных действий,
это может привести к коду очень большой вложенности и замаскировать номинальный вариант.

Следует также минимизировать количество возвратов из каждого метода. Стоит применять операторы возврата
только там, где это нужно — при условии, что они улучшают читабельность кода.

---

Не стоит злоупотреблять **рекурсией**! При её применении следует контролировать возможность
остановиться (даже если необходимо употребление бесконечной рекурсии, в чём я сильно сомневаюсь).

Применять рекурсию следует в рамках лишь одного метода, так как рекурсивный вызов целой цепочки методов
сложно не то, что понять, а и даже обнаружить. Понимание рекурсии, охватывающей несколько методов — крайне
утомительная и ресурсоёмкая задача. В качестве подстраховки можно применять счётчики безопасности и мониторинг
стека — второе применяется для того, чтобы не потерять контроль над рекурсией и, как следствие, чтобы она
не заняла память и ресурсы в объёме, большем, нежели это подразумевалось при проектировании (или вообще всех
доступных программе).

---

Блок `if(выражение){...}` принимает и вычисляет в булево значение. Если выражение принимает значение `TRUE`,
PHP выполнит инструкцию, а если оно принимает значение `FALSE` - проигнорирует.
При преобразовании в boolean, следующие значения рассматриваются как FALSE:
* само значение `boolean FALSE`;
* `integer 0` (ноль) и `-0` (минус ноль);
* `float 0.0` (ноль) и `-0.0` (минус ноль);
* пустая строка, и строка `"0"`;
* массив без элементов;
* особый тип `NULL` (включая неустановленные переменные);
* объекты SimpleXML, созданные из пустых тегов.

Все остальные значения рассматриваются как TRUE (включая любой `resource` и `NAN`).
Поэтому конструкция
```
if($model)
{
  //do something
}
```
будет эквивалентна
```
if(true)
{
  //do something
}
```
В логических выражениях следует использовать идентификаторы `TRUE` и `FALSE`,
а не значения 0 и 1.
К примеру,
```
if ($model->isDeleted == true)
{
  //do something
}
```
Для человека, читающего код, применение булевых выражений подскажет, что на данном участке кода
происходит обработка логического выражения. Есть разница между
```
if ($model->selected == 1)
{
  //do something
}
```
и
```
if ($model->selected == true)
{
  //do something
}
```
Если не знать контекста, может показаться, что оба выражения проверяют флаг `selected` на значение `TRUE`.
Однако весьма вероятно, что автор первого выражения хотел проверить значение `selected` на равенство `1`
(первый элемент, первый номер это уже не суть), а не на булев ответ *ИСТИНА* или *ЛОЖЬ*.  

При использовании сложных логических выражений есть смысл вынести их в логические функции,
а также разбивать их на части с использованием логических переменных.

---

> Рефакторить — не перерефакторить. (с) Конфузий

Именно так выглядит большинство кода, с которым я сталкиваюсь после прочтения
книги "Совершенный код".

---

Глубоко вложенный код — зло! Нормальное восприятие кода читателем нарушается после
третьего уровня вложенности, поэтому необходимо стараться минимизировать вложенность.

Вот методы, с помощью которых можно так или иначе уменьшить глубину вложенности:
* повторная проверка части условия;
* конвертирование в блоки *if-then-else*;
* преобразование к оператору case;
* факторизация глубоко вложенного кода в отдельный метод;
* использование объектной и полиморфной диспетчеризации;
* изменение кода с целью использования статусной переменной;
* использование сторожевых операторов для выхода из метода и пояснения номинального хода алгоритма;
* использование исключений;
* полное перепроектирование глубоко вложенного кода.

---

> При проектировании кода необходимо продумывать и то, как этот код тестировать.
То есть нужно составить некоторые критерии, по которым следует оценивать правильность
работы кода.

---

На будущее. Список того, что можно будет отрефакторить:
* замена магического числа на именованную константу;
* присвоение переменной более ясного и подходящего имени;
* иногда вместо промежуточной переменной лучше вставить само выражение;
* однако имеет место и обратное действие;
* переменную, служащую для нескольких задач, лучше заменить на несколько одноцелевых
переменных;
* если входной параметр метода служит в качестве локальной переменной, то стоит подумать,
не сделать ли для этого настоящую локалььную переменную;
* упрощение логических выражений путём введения грамотно и лаконично названных переменных,
документирующих суть выражения;
* вынесение сложного логического выражения в отдельную булеву функцию;
* вынесение повторяющегося механизма в отдельный метод;
* замена условных операторов (типа `case`) на вызов полиморфного метода;
* объединение повторяющихся в разных частях условного оператора фрагментов в одном месте;
* в качестве управляющей переменной цикла лучше применять `break` или `return`;
* возврат метода лучше осуществить сразу после получения ответа вместо установки возвращаемого
значения;
* если код метода достаточно прост, то можно не выделять его, а просто вставить его код
в необходимое место программы;
* сложный алгоритм по возможности нужно заменить на простой;
* не стоит оставлять неиспользуемые переменные в методе — лучше удалить их;
* достаточно объёмный метод можно превратить в отдельный класс;
* два похожих метода могут отличаться одной константой, в этом случае лучше объединить
их в один метод с приёмом необходимого параметра;
* и наоборот, если один метод кардинально меняет своё поведение в зависимости от переменной,
можно разделить его на отдельные методы, не передавая этот входной параметр;
* операции, содержащие запросы данных, стоит отделять от операций изменения данных;
* не стоит хранить классы, которые практически ничего не делают — их лучше удалить.

> Всё, что можно упростить без нарушения целостности и функциональности — упрощать!

При рефакторинге не стоит забывать перестраховываться частыми контрольными точками,
сохранённым первоначальным кодом, выполненным обзором изменений. Отдельные виды
рефакторинга стоит делать отдельно от других и не смешивать. При этом необходимо
адекватно оценивать рискованность рефакторинга, и в зависимости от этого изменять подход.

Стоит помнить, что рефакторинг **НЕ СТОИТ** проводить:
* как оправдание написания плохого кода с намерением исправить его позднее;
* как способ, позволяющий избежать переписывания кода.

Рефакторинг подчиняется тому же закону снижения выгоды, что и другие процессы программирования,
и к нему также относится правило 80/20 — 20% рефакторинга обеспечивает 80% выгоды.
Поэтому время, выделенное на рефакторинг стоит употреблять правильно.

Рефакторинг проводить **СТОИТ**:
* при создании новых методов (улучшение связанных с ним методов);
* при создании нового класса (аналогично);
* при исправлении дефектов (профилактика похожих ошибок в уязвимых местах);
* при работе с модулем, наиболее подверженным ошибкам (внушающим страх и ужас);
* при работе с чрезвычайно сложным модулем;
* при сопровождении программы с целью улучшения всего проходящего потока кода.

Зачастую "реальность" оказывается куда грязнее, чем кажется. Это нормально. Идеального
кода не бывает. Однако необходимо минимизировать количество "грязного" кода. Иногда приходится
омоложать уже существующие старые системы. При работе с ними можно воспользоваться
методикой разделения всей среды на  
* грязный реальный мир;
* чистый идеальный мир;
* интерфейс (мост) между этими мирами.

При этом реальный грязный мир необходимо постепенно, шаг за шагом, перемещать на
другую сторону "моста между мирами", улучшая и структурируя имеющиеся данные.

> *Главное правило **эволюции** ПО — при **эволюции** кода внутреннее качество
программы должно **повышаться**!*

---

Отдельному рассмотрению подлежит **Главных Технический Императив Разработки ПО** —
**управление сложностью**.

Инструментами борьбы с сложностью могут стать следующие советы:
* разделите систему на подсистемы на уровне архитектуры, чтобы концентрироваться
в каждый конкретный момент времени на меньшей части системы;
* тщательно определяйте интерфейсы классов, чтобы можно было игнорировать
внутреннее устройство классов;
* поддерживайте абстракцию, формируемую интерфейсом класса, чтобы не запоминать
ненужных деталей;
* избегайте глобальных данных, потому что их использование значительно увеличивает
процент кода, который нужно удерживать в уме в любой момент времени;
* избегайте глубоких иерархий наследования, потому что они предъявляют высокие
требования к интеллекту;
* избегайте глубокой вложенности циклов и условных операторов, поскольку их можно
заменить на более простые управляющие структуры, позволяющие бережнее расходовать
умственные ресурсы;
* избегайте операторов goto, так как они вносят в программу нелинейность,
за которой большинству людей трудно следить;
* тщательное определите подход к обработке ошибок, вместо того чтобы использовать
произвольную комбинацию разных методик;
* систематично используйте встроенный механизм исключений, поскольку он может
стать нелинейной управляющей структурой, которую при недисциплинированном
применении понять почти так же трудно, как и операторы goto;
* не позволяйте классам превращаться в монстров, достигающих размера целых программ;
* поддерживайте методы короткими;
* используйте ясные, очевидные имена переменных, чтобы не вспоминать детали
вроде «i — это индекс счета, а j — индекс клиента или наоборот?»;
* минимизируйте число параметров, передаваемых в метод, или, что еще важнее,
передавайте только те параметры, которые нужны для поддержания абстракции,
формируемой интерфейсом метода;
* используйте соглашения, чтобы не запоминать произвольные, несущественные
различия между разными фрагментами кода;
* и в целом, боритесь по мере возможности с различными мелкими "несущественными"
сложностями, которые в совокупности определённо приведут программу к сложности.

> Короче, главная цель проектирования и конструирования ПО — укрощение сложности.
Снижение сложности лежит в основе многих методик программирования, и, наверное,
его можно считать самым важным условием эффективного программирования.

---

> Пишите программы в первую очередь для людей и лишь во вторую — для компьютеров.
>
> (с) Stan Kelly-Bootle

Ещё один немаловажный аспект программирования — удобочитаемость кода.
> Общение с другими людьми — вот Святой Грааль самодокументирующегося кода.

Читабельность положительно влияет на такие аспекты программы, как:
* понятность;
* легкость выполнения обзоров;
* уровень ошибок;
* удобство отладки;
* легкость измерения;
* время разработки;
* внешнее качество.

---

> Итак, **ключевые моменты** в становлении **мастерства программирования**:
* **Главная цель программирования — управление сложностью**.
* **Процесс программирования** оказывает **большое влияние** на итоговый продукт.
* Групповое программирование является в большей степени **общением с другими
людьми, а не с компьютером**. Индивидуальное программирование — это в первую
очередь **общение с самим собой, а не с компьютером**.
* При неадекватном использовании конвенция программирования может оказаться
лекарством, причиняющим больше вреда, чем болезнь; при грамотном — конвенция
добавляет ценную структуру в среду разработки, помогает управлять сложностью
и облегчает общение.
* **Программирование в терминах проблемы, а не решения**, помогает управлять
сложностью.  
* Внимание к интеллектуальным предупреждающим знакам вроде сомнения особенно
важно в программировании, потому что **программирование — почти исключительно
умственная деятельность**.
* Чем **больше внимания** итерации вы уделяете на **конкретном этапе
разработки**, тем **лучше** будет результат этого этапа.
* **Догматичные методологии и разработка высококачественного ПО исключают друг
друга**. Заполняйте свой интеллектуальный инструментарий **альтернативными
подходами к программированию** и **улучшайте навык выбора инструмента**, лучше
всего подходящего для работы.


---

https://softfarm-hotfix-stage2.quartsoft.com/ru/crop/dashboard/spectral-analysis

Есть проблемка.

Если в адресную строку внести, допустим
https://softfarm-hotfix-stage2.quartsoft.com/ru/crop/dashboard/
, то оно заменяется на
https://softfarm-hotfix-stage2.quartsoft.com/ru/crop/dashboard/dashboard/spectral-analysis .

Если же ввести
https://softfarm-hotfix-stage2.quartsoft.com/ru/crop/dashboard
, то нормально заменяется на
https://softfarm-hotfix-stage2.quartsoft.com/ru/crop/dashboard/spectral-analysis

Думаю, корень проблемы представляет собой правила преобразования pretty URL из
обычного URL-запроса. Последний слэш, который вызывает проблему, указывает системе
о том, что нужно обратиться к методу `' '` экшна `spectral-analysis` контроллера
`dashboard`. Вознимает излишняя вложенность, из-за чего обращение к контроллеру
дублируется, что и приводит к ошибке 404.

Решение: стоит попробовать добавить ещё одно правило, которое учитывает этот
вырожденный случай, и в нём учесть возможный слэш в конце.

Или же другой способ. Добавить исключение для данного инцидента (сообщение об
ошибке или редирект), дабы уведомить пользователя, в чём дело.

Хотя возможно я слишком сильно прикапываюсь к мелочам...

---

```
// app/views/layouts/main.php
<?php
'items' => [
    ['label' => 'Home', 'url' => ['/site/index']],
    ['label' => 'About', 'url' => ['/site/about']],
    ['label' => 'Contact', 'url' => ['/site/contact']],
    ['label' => 'User', 'url' => ['/user']],
    Yii::$app->user->isGuest ?
        ['label' => 'Login', 'url' => ['/user/login']] : // or ['/user/login-email']
        ['label' => 'Logout (' . Yii::$app->user->displayName . ')',
            'url' => ['/user/logout'],
            'linkOptions' => ['data-method' => 'post']],
],
```

Оказыватся, делать вывод ссылок в зависимости от роли пользователя можно и тернарным оператором, а именно следующим образом:
```
    Yii::$app->user->isGuest ?
        ['label' => 'Login', 'url' => ['/user/login']] : 
        ['label' => 'Logout (' . Yii::$app->user->displayName . ')',
            'url' => ['/user/logout'],
            'linkOptions' => ['data-method' => 'post']],
```

Должен признаться, это довольно прикольно

---